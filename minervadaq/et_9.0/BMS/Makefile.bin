#
# Makefile for building executables
#

ifndef MAIN_FILES
  MAIN_FILES = $(shell $(BMS_HOME)/main_files.sh)
endif

MAIN = $(filter-out $(NO_MAIN_FILES), $(basename $(MAIN_FILES)))
EXE_NAMES = $(addsuffix $(DEBUG_SUFFIX),$(basename $(MAIN)))
EXE_PATHNAMES = $(foreach s,$(EXE_NAMES),$(BIN_DIR)/$s)

OUTPUT_OPTION = -o $(OBJ_DIR)/$@
VPATH = $(OBJ_DIR):$(BIN_DIR)


all: mkdirs $(DEPS) $(EXE_NAMES) $(OTHER_TARGETS)


mkdirs:
	@mkdir -p $(BIN_DIR)
	@mkdir -p $(OBJ_DIR)
	@mkdir -p $(DEP_DIR)

install: all
	mkdir -p $(INSTALL_DIR)/$(BMS_OSNAME)/bin
	@echo "Installing $(MODULE_NAME) executables:"
	@for i in $(notdir $(EXE_PATHNAMES) $(OTHER_TARGETS)); do \
	   echo "  $(INSTALL_DIR)/$(BMS_OSNAME)/bin/$$i"; \
	   cp -p $(BIN_DIR)/$$i $(INSTALL_DIR)/$(BMS_OSNAME)/bin/$$i; \
           done;

uninstall: 
	@echo "Uninstalling $(MODULE_NAME) executables:"
	@for i in $(notdir $(EXE_PATHNAMES) $(OTHER_TARGETS)); do \
	   echo "  $(INSTALL_DIR)/$(BMS_OSNAME)/bin/$$i"; \
	   rm -f $(INSTALL_DIR)/$(BMS_OSNAME)/bin/$$i; \
           done;

relink: execClean all

clean:
	rm -rf $(BIN_DIR) $(OBJ_DIR) $(DEP_DIR) *.o *.bak *~ core

distClean: clean
	rm -rf .$(BMS_OSNAME)

execClean:
	rm -f $(EXE_PATHNAMES) $(OTHER_TARGETS)

here: all
	@for i in $(notdir $(EXE_PATHNAMES) $(OTHER_TARGETS)); do \
	   cp -p $(BIN_DIR)/$$i ./$$i; \
           done;

hereClean:
	rm -rf $(notdir $(EXE_PATHNAMES) $(OTHER_TARGETS))

#
# These are the implicit rules (listed by make -p):
#

#LINK.c = $(CC) $(CFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)
#%: %.c
#
#        $(LINK.c) $^ $(LOADLIBES) $(LDLIBS) -o $@
#
#LINK.cc = $(CXX) $(CXXFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)
#%: %.cc
#  commands to execute (built-in):
#        $(LINK.cc) $^ $(LOADLIBES) $(LDLIBS) -o $@
 
#COMPILE.c = $(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c
#%.o: %.c
#	$(COMPILE.c) $(OUTPUT_OPTION) $<
#
#COMPILE.cc = $(CXX) $(CXXFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c
#%.o: %.cc
#  commands to execute (built-in):
#        $(COMPILE.cc) $(OUTPUT_OPTION) $<

#LINK.o = $(CC) $(LDFLAGS) $(TARGET_ARCH)
#%: %.o
#        $(LINK.o) $^ $(LOADLIBES) $(LDLIBS) -o $@
#

# The following is a slight change from the original implicit rule.
# Because of the generated dependencies (n.o : n.c x.h), it turns out
# that changing a header file causes the header to be recompiled by the
# implicit rule which, in turn, generates an error.
# To avoid that, state explicitly that each executable is linked with only it's .o file.
%: %.o $(OTHER_DEPS)
	$(LD) $(LD_DIRS) $(LDFLAGS) $(OBJ_DIR)/$@.o $(LD_LIBS) $(MISC_LIBS) -o $(BIN_DIR)/$@
        
# get rid of these implicit rules so the ones for %.o:%.c(c) and %:%.o will be exercised instead
%: %.c
%: %.cc
